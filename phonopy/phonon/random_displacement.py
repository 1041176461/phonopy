# Copyright (C) 2018 Atsushi Togo
# All rights reserved.
#
# This file is part of phonopy.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# * Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in
#   the documentation and/or other materials provided with the
#   distribution.
#
# * Neither the name of the phonopy project nor the names of its
#   contributors may be used to endorse or promote products derived
#   from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import numpy as np
from phonopy.harmonic.dynmat_to_fc import get_commensurate_points_in_integers
from phonopy.structure.cells import determinant
from phonopy.structure.brillouin_zone import get_qpoints_in_Brillouin_zone
from phonopy.units import VaspToTHz, THzToEv, Kb, Hbar, AMU, EV, Angstrom, THz


class RandomDisplacement(object):
    """Generate Random displacements by Canonical ensenmble.

    Attributes
    ----------
    u : ndarray
        Random atomic displacements generated by canonical distribution of
        harmonic oscillator.
        shape=(supercell_atoms, 3)
        dtype='double'

    """

    def __init__(self,
                 dynamical_matrix,
                 cutoff_frequency=1e-2,
                 factor=VaspToTHz):
        """

        Parameters
        ----------
        supercell_matrix : array_like
            Supercell matrix.
            shape=(3, 3)
            dtype='intc'
        cutoff_frequency : float, optional
            Above this cutoff frequency in THz, it is decided if each phonon
            mode is included or not. Default is 0.01 THz.
        factor : float, optional
            Unit conversion factor of phonon frequency to THz. Default is that
            for the VASP unit system.

        """

        self._dynmat = dynamical_matrix
        if cutoff_frequency is None or cutoff_frequency < 0:
            self._cutoff_frequency = 0.0
        else:
            self._cutoff_frequency = cutoff_frequency
        self._factor = factor
        self._T = None
        self.u = None

        self._unit_conversion = (Hbar * EV / AMU / THz
                                 / (2 * np.pi) / Angstrom ** 2)

    def run(self, T):
        """

        Parameters
        ----------
        T : float
            Temperature in Kelvin.

        """

        plat = self._dynmat.primitive.get_cell()
        slat = self._dynmat.supercell.get_cell()
        rec_lat = np.linalg.inv(plat)
        supercell_matrix = np.rint(np.dot(slat, rec_lat).T).astype(int)
        comm_points = get_commensurate_points_in_integers(supercell_matrix)
        N = determinant(supercell_matrix)
        ii, ij = self._categorize_points(comm_points, N)
        assert len(ii) + len(ij) * 2 == N

        u_ii = self._solve_ii(ii, N, rec_lat, comm_points, T)
        u_ij = self._solve_ij(ij, N, rec_lat, comm_points, T)
        mass = self._dynmat.supercell.get_masses()
        u = np.array(((u_ii + u_ij).T / np.sqrt(mass * N)).T,
                     dtype='double', order='C')
        self.u = u

    def _solve_ii(self, ii, N, rec_lat, comm_points, T):
        qpoints = get_qpoints_in_Brillouin_zone(
            rec_lat, comm_points[ii] / float(N), only_unique=True)

        s2p = self._dynmat.primitive.s2p_map
        p2p = self._dynmat.primitive.p2p_map
        s2pp = [p2p[i] for i in s2p]
        pos = self._dynmat.supercell.get_scaled_positions()
        u = np.zeros((len(pos), 3), dtype='double')

        for q in qpoints:
            self._dynmat.set_dynamical_matrix(q)
            dm = self._dynmat.dynamical_matrix
            eigvals, eigvecs = np.linalg.eigh(dm.real)
            phase = np.cos(2 * np.pi * np.dot(pos, q))
            sigma = self._get_sigma(eigvals, T)
            dist_func = sigma * np.random.randn(len(eigvals))
            u_red = np.dot(eigvecs, dist_func).reshape(-1, 3)
            for i, (phase_i, j) in enumerate(zip(phase, s2pp)):
                u[i] += phase_i * u_red[j]

        return u

    def _solve_ij(self, ij, N, rec_lat, comm_points, T):
        qpoints = get_qpoints_in_Brillouin_zone(
            rec_lat, comm_points[ij] / float(N), only_unique=True)

        s2p = self._dynmat.primitive.s2p_map
        p2p = self._dynmat.primitive.p2p_map
        s2pp = [p2p[i] for i in s2p]
        pos = self._dynmat.supercell.get_scaled_positions()
        u = np.zeros((len(pos), 3), dtype='double')

        for q in qpoints:
            self._dynmat.set_dynamical_matrix(q)
            dm = self._dynmat.dynamical_matrix
            eigvals, eigvecs = np.linalg.eigh(dm)
            phase = np.exp(2j * np.pi * np.dot(pos, q))
            sigma = self._get_sigma(eigvals, T)

            dist_func = sigma * np.random.randn(len(eigvals))
            u_red = np.dot(eigvecs, dist_func).reshape(-1, 3)
            for i, (phase_i, j) in enumerate(zip(phase, s2pp)):
                u[i] += (phase_i * u_red[j]).real

            dist_func = sigma * np.random.randn(len(eigvals))
            u_red = np.dot(eigvecs, dist_func).reshape(-1, 3)
            for i, (phase_i, j) in enumerate(zip(phase, s2pp)):
                u[i] -= (phase_i * u_red[j]).imag

        return u * np.sqrt(2)

    def _get_sigma(self, eigvals, T, mode=2):
        if mode == 0:  # Ignore modes having negative eigenvalues
            idx = np.where(eigvals * self._factor ** 2
                           > self._cutoff_frequency ** 2)[0]
            freqs = np.sqrt(eigvals[idx]) * self._factor
            n = 1.0 / (np.exp(freqs * THzToEv / (Kb * T)) - 1)
            sigma2 = self._unit_conversion / freqs * (0.5 + n)
            sigma = np.zeros(len(eigvals), dtype='double')
            sigma[idx] = np.sqrt(sigma2)
        elif mode == 1:  # Use absolute frequencies
            idx = np.where(abs(eigvals) * self._factor ** 2
                           > self._cutoff_frequency ** 2)[0]
            freqs = np.sqrt(abs(eigvals[idx])) * self._factor
            n = 1.0 / (np.exp(freqs * THzToEv / (Kb * T)) - 1)
            sigma2 = self._unit_conversion / freqs * (0.5 + n)
            sigma = np.zeros(len(eigvals), dtype='double')
            sigma[idx] = np.sqrt(sigma2)
        elif mode == 2:  # Raise to lowest positive absolute value
            idx = np.where(eigvals * self._factor ** 2
                           > self._cutoff_frequency ** 2)[0]
            idx_n = np.where(eigvals * self._factor ** 2
                             < -self._cutoff_frequency ** 2)[0]
            freqs = np.sqrt(eigvals[idx]) * self._factor
            n = 1.0 / (np.exp(freqs * THzToEv / (Kb * T)) - 1)
            sigma2 = self._unit_conversion / freqs * (0.5 + n)
            sigma = np.zeros(len(eigvals), dtype='double')
            sigma[idx] = np.sqrt(sigma2)
            sigma[idx_n] = sigma[idx[np.argmin(freqs)]]

        return sigma

    def _categorize_points(self, points, N):
        ii = []
        ij = []
        for i, p in enumerate(points):
            for j, _p in enumerate(points):
                if ((p + _p) % N == 0).all():
                    if i == j:
                        ii.append(i)
                    elif i < j:
                        ij.append(i)
                    break
        return ii, ij
